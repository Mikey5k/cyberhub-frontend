import { NextRequest, NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export const runtime = "nodejs";

// Firestore REST API helper
const FIRESTORE_URL = `https://firestore.googleapis.com/v1/projects/${process.env.FIREBASE_PROJECT_ID}/databases/(default)/documents`;

async function firestoreRequest(endpoint: string, method: string = 'GET', body?: any) {
  const url = `${FIRESTORE_URL}${endpoint}`;
  const apiKey = process.env.FIREBASE_API_KEY;
  
  if (!apiKey) {
    throw new Error("Firebase API key not configured");
  }

  const options: RequestInit = {
    method,
    headers: {
      'Content-Type': 'application/json',
    },
  };

  if (body) {
    options.body = JSON.stringify(body);
  }

  // Add API key as query parameter
  const finalUrl = `${url}?key=${apiKey}`;
  const response = await fetch(finalUrl, options);
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error(`Firestore API error (${response.status}):`, errorText);
    throw new Error(`Firestore request failed: ${response.status} ${errorText}`);
  }
  
  return await response.json();
}

// Helper functions
function generateToken(userId: string, email: string, role: string) {
  const JWT_SECRET = process.env.JWT_SECRET || 'veritas-secret-key-change-in-production';
  return jwt.sign(
    { userId, email, role },
    JWT_SECRET,
    { expiresIn: '7d' }
  );
}

async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// Convert Firestore document to user object
function convertFirestoreUser(doc: any): any {
  const fields = doc.fields || {};
  const user: any = { id: doc.name.split('/').pop() };
  
  Object.keys(fields).forEach(key => {
    const field = fields[key];
    if (field.stringValue !== undefined) user[key] = field.stringValue;
    else if (field.integerValue !== undefined) user[key] = Number(field.integerValue);
    else if (field.booleanValue !== undefined) user[key] = field.booleanValue;
    else if (field.timestampValue !== undefined) user[key] = field.timestampValue;
  });
  
  return user;
}

// Convert user object to Firestore fields
function convertToFirestoreFields(data: any): any {
  const fields: any = {};
  
  Object.keys(data).forEach(key => {
    const value = data[key];
    
    if (value === null || value === undefined) {
      return;
    }
    
    if (typeof value === 'string') {
      fields[key] = { stringValue: value };
    } else if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        fields[key] = { integerValue: value.toString() };
      } else {
        fields[key] = { doubleValue: value };
      }
    } else if (typeof value === 'boolean') {
      fields[key] = { booleanValue: value };
    }
  });
  
  return fields;
}

// GET - Get user by email or ID
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const email = searchParams.get('email');
    const id = searchParams.get('id');

    if (!email && !id) {
      return NextResponse.json(
        { success: false, error: 'Email or ID parameter required' },
        { status: 400 }
      );
    }

    let user: any = null;
    
    if (id) {
      // Get user by ID
      try {
        const response = await firestoreRequest(`/users/${id}`);
        if (response && response.fields) {
          user = convertFirestoreUser(response);
        }
      } catch (error) {
        // User not found, continue to email search
      }
    }
    
    if (!user && email) {
      // Search user by email (Firestore doesn't support queries well in REST API, so we fetch all and filter)
      try {
        const response = await firestoreRequest('/users');
        if (response && response.documents) {
          const users = response.documents.map(convertFirestoreUser);
          user = users.find((u: any) => u.email === email);
        }
      } catch (error) {
        console.error('Error searching user by email:', error);
      }
    }

    if (!user) {
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    // Don't return password hash
    const { passwordHash, ...userWithoutPassword } = user;
    
    return NextResponse.json({
      success: true,
      user: userWithoutPassword
    });

  } catch (error) {
    console.error('Error fetching user:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// POST - Create new user (sign up)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { email, password, name, phone, role = 'user' } = body;

    // Validation
    if (!email || !password || !name) {
      return NextResponse.json(
        { success: false, error: 'Email, password, and name are required' },
        { status: 400 }
      );
    }

    // Check if user already exists by email
    try {
      const response = await firestoreRequest('/users');
      if (response && response.documents) {
        const users = response.documents.map(convertFirestoreUser);
        const existingUser = users.find((u: any) => u.email === email);
        if (existingUser) {
          return NextResponse.json(
            { success: false, error: 'User with this email already exists' },
            { status: 409 }
          );
        }
      }
    } catch (error) {
      // If collection doesn't exist yet, that's fine
    }

    // Hash password
    const passwordHash = await hashPassword(password);

    // Create user
    const userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date().toISOString();
    
    const userData = {
      id: userId,
      email,
      passwordHash,
      name,
      phone: phone || '',
      role,
      createdAt: now,
      updatedAt: now
    };

    const firestoreData = {
      fields: convertToFirestoreFields(userData)
    };

    await firestoreRequest(`/users/${userId}`, 'PATCH', firestoreData);

    // Generate JWT token
    const token = generateToken(userId, email, role);

    // Don't return password hash
    const { passwordHash: _, ...userWithoutPassword } = userData;

    return NextResponse.json({
      success: true,
      message: 'User created successfully',
      user: userWithoutPassword,
      token
    }, { status: 201 });

  } catch (error) {
    console.error('Error creating user:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// PATCH - Login user (email/password)
export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json();
    const { email, password } = body;

    if (!email || !password) {
      return NextResponse.json(
        { success: false, error: 'Email and password are required' },
        { status: 400 }
      );
    }

    // Find user by email
    let user: any = null;
    try {
      const response = await firestoreRequest('/users');
      if (response && response.documents) {
        const users = response.documents.map(convertFirestoreUser);
        user = users.find((u: any) => u.email === email);
      }
    } catch (error) {
      console.error('Error searching user by email:', error);
    }

    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Invalid email or password' },
        { status: 401 }
      );
    }

    // Verify password
    const isValidPassword = await verifyPassword(password, user.passwordHash);
    if (!isValidPassword) {
      return NextResponse.json(
        { success: false, error: 'Invalid email or password' },
        { status: 401 }
      );
    }

    // Generate JWT token
    const token = generateToken(user.id, user.email, user.role);

    // Don't return password hash
    const { passwordHash, ...userWithoutPassword } = user;

    return NextResponse.json({
      success: true,
      message: 'Login successful',
      user: userWithoutPassword,
      token
    });

  } catch (error) {
    console.error('Error logging in:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// PUT - Update user (optional for now)
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { id, name, phone } = body;

    if (!id) {
      return NextResponse.json(
        { success: false, error: 'User ID is required' },
        { status: 400 }
      );
    }

    // Check if user exists
    try {
      await firestoreRequest(`/users/${id}`);
    } catch (error) {
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    // Update user data
    const updateData: any = {
      updatedAt: new Date().toISOString()
    };

    if (name) updateData.name = name;
    if (phone !== undefined) updateData.phone = phone;

    const firestoreData = {
      fields: convertToFirestoreFields(updateData)
    };

    await firestoreRequest(`/users/${id}`, 'PATCH', firestoreData);

    return NextResponse.json({
      success: true,
      message: 'User updated successfully'
    });

  } catch (error) {
    console.error('Error updating user:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}